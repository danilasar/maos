/*
 * Таблица символов объектного файла содержит информацию,
 * необходимую для нахождения и перемещения
 * символических определений и ссылок программы. Индекс
 * таблицы символов является индексом в этом массиве.
 *
 * Индекс 0 одновременно обозначает первую запись в таблице
 * и служит в качестве индекса неопределенного символа.
 *
 *
 * ---------------------------------------------------------------------
 * 5.1. Запись в таблице символов
 * ---------------------------------------------------------------------
 *
 * Запись в таблице символов имеет следующий формат:
 */

// 32-разрядный вариант
// Отличается от 64-разрядного размерностью
typedef struct {
    Elf32_Word     st_name;
    Elf32_Addr     st_value;
    Elf32_Word     st_size;
    unsigned char  st_info;
    unsigned char  st_other;
    Elf32_Half     st_shndx;
} Elf32_Sym;

typedef struct {
    /*
     * Имя символа.
     * Это поле содержит индекс в таблице строк символов
     * объектного файла, которая хранит символьные
     * представления имен. Если значение ненулевое,
     * оно представляет собой индекс в таблице строк,
     * который указывает на имя символа. В противном
     * случае, запись в таблице символов не имеет имени.
     *
     * Примечание:
     * Внешние символы C имеют одинаковые имена в исходном
     * коде C и в таблицах символов объектных файлов.
     */
    Elf64_Word     st_name;
    /*
     * Тип и атрибуты привязки символа.
     * Это поле определяет тип символа и его атрибуты
     * привязки (binding). Список значений и их смыслов
     * приведен ниже.
     */
    unsigned char  st_info;
    /*
     * Видимость символа.
     * В настоящее время это поле определяет видимость
     * символа. Список значений и их смыслов приведен
     * ниже. Остальные биты содержат 0 и не имеют
     * определенного значения.
     */
    unsigned char  st_other;
    /*
     * Индекс секции.
     * Каждая запись в таблице символов определяется
     * по отношению к некоторой секции. Это поле
     * содержит соответствующий индекс в таблице
     * заголовков секций. Некоторые индексы секций
     * имеют специальное значение.
     * Если это поле содержит SHN_XINDEX, то фактический
     * индекс заголовка секции слишком велик, чтобы
     * поместиться в это поле, и содержится в связанной
     * секции типа SHT_SYMTAB_SHNDX.
     */
    Elf64_Half     st_shndx;
    /*
     * Значение символа.
     * Это поле содержит значение, связанное с символом.
     * В зависимости от контекста, это может быть
     * абсолютное значение, адрес и т.д.
     */
    Elf64_Addr     st_value;
    /*
     * Размер символа.
     * Многие символы имеют связанные с ними размеры.
     * Например, размер объекта данных - это количество
     * байт, содержащихся в объекте. Это поле содержит 0,
     * если символ не имеет размера или его размер неизвестен.
     */
    Elf64_Xword    st_size;
} Elf64_Sym;

/*
 * Макросы для работы с полем st_info
 */
#define ELF32_ST_BIND(i)   ((i)>>4)
#define ELF32_ST_TYPE(i)   ((i)&0xf)
#define ELF32_ST_INFO(b,t) (((b)<<4)+((t)&0xf))

#define ELF64_ST_BIND(i)   ((i)>>4)
#define ELF64_ST_TYPE(i)   ((i)&0xf)
#define ELF64_ST_INFO(b,t) (((b)<<4)+((t)&0xf))

/*
 * Макросы для работы с полем st_other
 */
#define ELF32_ST_VISIBILITY(o) ((o)&0x7)
#define ELF64_ST_VISIBILITY(o) ((o)&0x7)

/*
 * ---------------------------------------------------------------------
 * 5.3. Тип символа
 * ---------------------------------------------------------------------
 * Тип символа предоставляет общую классификацию для связанной
 * с ним сущности.
 */

/*
 * Типы символов
 */
#define STT_NOTYPE      0    // Тип символа не указан.

#define STT_OBJECT      1    // Символ связан с объектом данных, таким как
                             // переменная, массив и т.д.

#define STT_FUNC        2    // Символ связан с функцией или другим
                             // исполняемым кодом.

#define STT_SECTION     3    // Символ связан с секцией. Записи этого типа
                             // существуют в основном для перемещения
                             // и обычно имеют локальную привязку (STB_LOCAL).

#define STT_FILE        4    // По соглашению, имя символа содержит имя
                             // исходного файла, связанного с объектным
                             // файлом. Символ файла имеет привязку STB_LOCAL,
                             // индекс его секции - SHN_ABS, и он предшествует
                             // другим символам STB_LOCAL для этого файла.

#define STT_COMMON      5    // Символ отмечает неинициализированный общий
                             // блок.

#define STT_TLS         6    // Символ определяет сущность локального
                             // хранилища потока. При определении он указывает
			     // смещение для символа, а не фактический адрес.

#define STT_LOOS        10   // Начало диапазона, зарезервированного для
                             // семантики, специфичной для операционной
                             // системы.

#define STT_HIOS        12   // Конец диапазона для ОС-специфичной семантики.

#define STT_LOPROC      13   // Начало диапазона, зарезервированного для
                             // семантики, специфичной для процессора.

#define STT_HIPROC      15   // Конец диапазона для процессорно-специфичной
                             // семантики.

/*
 * Символы-функции (с типом STT_FUNC) в разделяемых объектных файлах
 * имеют особое значение. Когда другой объектный файл ссылается на
 * функцию из разделяемого объекта, компоновщик автоматически
 * создает для этого символа запись в таблице связывания процедур
 * (PLT). Символы разделяемых объектов с типами, отличными от
 * STT_FUNC, не будут автоматически вызываться через PLT.
 *
 * Символы с типом STT_COMMON помечают неинициализированные общие
 * блоки. В перемещаемых объектах этим символам не выделяется
 * пространство, и они должны иметь специальный индекс секции SHN_COMMON.
 * В разделяемых объектах и исполняемых файлах этим символам должно
 * быть выделено место в какой-либо секции определяющего объекта.
 *
 * При обработке перемещаемых объектов символы STT_COMMON трактуются
 * так же, как и другие символы с индексом SHN_COMMON. Если компоновщик
 * выделяет пространство для символа SHN_COMMON в выходной секции,
 * он должен сохранить тип выходного символа как STT_COMMON.
 *
 * Когда динамический компоновщик встречает ссылку на символ, который
 * разрешается в определение типа STT_COMMON, он может изменить свои
 * правила разрешения символов: вместо того чтобы привязывать ссылку
 * к первому найденному символу с данным именем, он ищет первый
 * символ с этим именем, тип которого отличен от STT_COMMON. Если такой
 * символ не найден, он ищет определение STT_COMMON с таким именем,
 * у которого наибольший размер.
 *
 * ---------------------------------------------------------------------
 * 5.4. Видимость символа
 * ---------------------------------------------------------------------
 * Видимость символа, хотя и может быть указана в перемещаемом
 * объекте, определяет, как к этому символу можно будет получить
 * доступ после того, как он станет частью исполняемого файла
 * или разделяемого объекта.
 */

/*
 * Видимость символов
 */
#define STV_DEFAULT     0  // Видимость символов с атрибутом STV_DEFAULT
                           // определяется типом привязки символа. То есть,
                           // глобальные и слабые символы  видны за пределами
			   // своего определяющего компонента (исполняемого
			   // файла или разделяемого объекта). Локальные
			   // символы скрыты. Глобальные и слабые символы
			   // также могут быть вытеснены определениями с тем
			   // же именем в другом компоненте.

#define STV_INTERNAL    1  // Значение этого атрибута видимости может быть
                           // определено в дополнениях psABI для дальнейшего
                           // ограничения скрытых символов. Универсальные
                           // инструменты могут безопасно рассматривать
                           // внутренние символы как скрытые.

#define STV_HIDDEN      2  // Символ, определённый в текущем компоненте,
                           // является скрытым, если его имя не видно
                           // другим компонентам. Такой символ обязательно
                           // является защищённым. Этот атрибут
                           // может использоваться для контроля внешнего
                           // интерфейса компонента.

#define STV_PROTECTED   3  // Символ, определённый в текущем компоненте,
                           // является защищённым, если он виден в других
                           // компонентах, но не может быть вытеснен. Это
                           // означает, что любая ссылка на такой символ
                           // изнутри определяющего компонента должна
                           // разрешаться в определение в этом же компоненте.
                           // Символ с привязкой STB_LOCAL не может иметь
                           // видимость STV_PROTECTED.

#define STV_EXPORTED    4  // Этот атрибут видимости гарантирует, что
                           // символ остаётся глобальным. В отличие от
                           // символов STV_DEFAULT, на видимость которых
                           // могут влиять другие запросы, STV_EXPORTED
                           // гарантирует, что видимость символа не будет
                           // уменьшена.

#define STV_SINGLETON   5  // Этот атрибут видимости зарезервирован для
                           // дополнений psABI. Если реализован, он
                           // гарантирует, что все ссылки в пределах
                           // процесса привязываются к единственному
                           // экземпляру определения символа.

#define STV_ELIMINATE   6  // Этот атрибут видимости зарезервирован для
                           // дополнений psABI. Если реализован, он
                           // предотвращает запись символа в динамическую
                           // таблицу символов. В остальном его можно
                           // рассматривать так же, как STV_HIDDEN.

/*
 * Ни один из атрибутов видимости не влияет на разрешение символов
 * внутри исполняемого файла или разделяемого объекта во время
 * компоновки - это разрешение контролируется типом привязки.
 * После того как компоновщик выбрал своё разрешение, эти атрибуты
 * налагают два требования:
 *
 * Во-первых, все атрибуты видимости, отличные от стандартного,
 * применительно к ссылке на символ, подразумевают, что определение
 * для удовлетворения этой ссылки должно быть предоставлено в пределах
 * текущего исполняемого файла или разделяемого объекта. Если у такой
 * ссылки на символ нет определения внутри компонуемого компонента,
 * то ссылка должна иметь слабую привязку (STB_WEAK) и разрешается
 * в ноль.
 *
 * Во-вторых, если какая-либо ссылка на имя или его определение
 * является символом с атрибутом видимости, отличным от стандартного,
 * этот атрибут видимости должен быть распространен на разрешающий
 * символ в скомпонованном объекте. Если для различных ссылок на
 * символ или его определений указаны разные атрибуты видимости,
 * то на разрешающий символ в скомпонованном объекте должен быть
 * распространен наиболее ограничивающий атрибут видимости.
 * Атрибуты в порядке от наименее до наиболее ограничивающего:
 * STV_PROTECTED, STV_HIDDEN, STV_INTERNAL и STV_EXPORTED.
 *
 * ---------------------------------------------------------------------
 * 5.5. Индекс секции
 * ---------------------------------------------------------------------
 * Если значение символа ссылается на определенное местоположение
 * внутри секции, его поле индекса секции, st_shndx, содержит
 * индекс в таблице заголовков секций. При перемещении секции во
 * время релокации значение символа также изменяется, и ссылки на
 * символ продолжают указывать на то же место в программе.
 * Некоторые специальные значения индекса секции имеют другую
 * семантику.
 *
 * SHN_ABS
 *   Символ имеет абсолютное значение, которое не изменится
 *   в результате релокации.
 *
 * SHN_COMMON
 *   Символ обозначает общий блок, который еще не был размещен.
 *   Значение символа (st_value) задает требования к выравниванию,
 *   аналогично полю sh_addralign секции. Компоновщик выделит
 *   память для символа по адресу, кратному st_value. Размер
 *   символа (st_size) указывает, сколько байт требуется. Символы
 *   с индексом секции SHN_COMMON могут появляться только в
 *   перемещаемых объектах.
 *
 * SHN_UNDEF
 *   Этот индекс таблицы секций означает, что символ не определен.
 *   Когда компоновщик объединяет этот объектный файл с другим,
 *   который определяет указанный символ, ссылки этого файла на
 *   символ будут связаны с фактическим определением.
 *
 * SHN_XINDEX
 *   Управляющее значение. Оно указывает, что символ ссылается
 *   на определённое местоположение внутри секции, но индекс
 *   заголовка этой секции слишком велик, чтобы быть представленным
 *   непосредственно в записи таблицы символов. Фактический индекс
 *   заголовка секции находится в связанной секции типа SHT_SYMTAB_SHNDX.
 *
 * ---------------------------------------------------------------------
 * 5.6. Первая запись таблицы символов
 * ---------------------------------------------------------------------
 * Запись в таблице символов с индексом 0 (STN_UNDEF) зарезервирована;
 * она содержит следующие значения.
 *
 *      +------------+-----------+------------------------------+
 *      |    Поле    |  Значение |          Примечание          |
 *      +------------+-----------+------------------------------+
 *      | st_name    | 0         | Нет имени                    |
 *      | st_value   | 0         | Нулевое значение             |
 *      | st_size    | 0         | Нет размера                  |
 *      | st_info    | 0         | Нет типа, локальная привязка |
 *      | st_other   | 0         | Видимость по умолчанию       |
 *      | st_shndx   | SHN_UNDEF | Нет секции                   |
 *      +------------+-----------+------------------------------+
 *
 * ---------------------------------------------------------------------
 * 5.7. Значение символа
 * ---------------------------------------------------------------------
 * Записи в таблице символов для разных типов объектных файлов имеют
 * несколько различные интерпретации для поля st_value.
 *
 * - В перемещаемых файлах st_value содержит требования к
 *   выравниванию для символа, у которого индекс секции равен
 *   SHN_COMMON.
 *
 * - В перемещаемых файлах st_value содержит смещение внутри
 *   секции для определённого символа. st_value - это смещение
 *   от начала секции, которую идентифицирует st_shndx.
 *
 * - В исполняемых и разделяемых объектных файлах st_value
 *   содержит виртуальный адрес. Чтобы сделать символы этих
 *   файлов более полезными для динамического компоновщика,
 *   смещение в секции (интерпретация для файла) уступает
 *   место виртуальному адресу (интерпретация для памяти),
 *   для которого номер секции не имеет значения.
 *
 * Несмотря на это различие в интерпретации, st_value для
 * данного символа несет один и тот же смысл в разных типах
 * объектов ELF.
 */

