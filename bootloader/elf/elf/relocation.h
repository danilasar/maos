/*
 * ---------------------------------------------------------------------
 * 6.1. Запись о перемещении
 * ---------------------------------------------------------------------
 * Записи о перемещении имеют следующие форматы:
 */

typedef struct {
    Elf32_Addr   r_offset;
    Elf32_Word   r_info;
} Elf32_Rel;

typedef struct {
    Elf32_Addr   r_offset;
    Elf32_Word   r_info;
    Elf32_Sword  r_addend;
} Elf32_Rela;

typedef struct {
    /*
     * Местоположение.
     * Это поле указывает место, к которому применяется действие
     * по перемещению. Для перемещаемого файла значением является
     * смещение в байтах от начала секции до единицы хранения,
     * затрагиваемой перемещением. Для исполняемого файла или
     * разделяемого объекта значением является виртуальный адрес
     * затрагиваемой единицы хранения.
     */
    Elf64_Addr   r_offset;
    /*
     * Индекс символа и тип перемещения.
     * Это поле содержит как индекс в таблице символов, относительно
     * которого должно быть выполнено перемещение, так и тип
     * применяемого перемещения. Типы перемещений специфичны для
     * процессора.
     */
    Elf64_Xword  r_info;
} Elf64_Rel;

typedef struct {
    /*
     * Местоположение.
     * (См. описание в Elf64_Rel)
     */
    Elf64_Addr   r_offset;
    /*
     * Индекс символа и тип перемещения.
     * (См. описание в Elf64_Rel)
     */
    Elf64_Xword  r_info;
    /*
     * Адденд.
     * Это поле определяет константный адденд, используемый для
     * вычисления значения, которое будет сохранено в перемещаемое
     * поле.
     */
    Elf64_Sxword r_addend;
} Elf64_Rela;

/*
 * Макросы для извлечения индекса символа и типа перемещения из r_info
 */
#define ELF32_R_SYM(i)     ((i)>>8)
#define ELF32_R_TYPE(i)    ((unsigned char)(i))
#define ELF32_R_INFO(s,t)  (((s)<<8)+(unsigned char)(t))

#define ELF64_R_SYM(i)     ((i)>>32)
#define ELF64_R_TYPE(i)    ((i)&0xffffffffL)
#define ELF64_R_INFO(s,t)  (((s)<<32)+((t)&0xffffffffL))

/*
 * Как было указано ранее, только записи Elf32_Rela и Elf64_Rela
 * содержат явный адденд. Записи типа Elf32_Rel и Elf64_Rel хранят
 * неявный адденд в месте, которое подлежит модификации.
 *
 * Секция перемещений ссылается на две другие секции: таблицу
 * символов и секцию, которую нужно изменить. Поля sh_info и
 * sh_link заголовка секции определяют эти связи.
 *
 * Хотя интерпретация r_offset меняется для разных типов объектных
 * файлов, чтобы обеспечить эффективный доступ, значения типов
 * перемещений остаются теми же.
 *
 * Типичное применение перемещения ELF заключается в определении
 * значения ссылочного символа, извлечении адденда, применении
 * выражения, подразумеваемого типом перемещения, к символу и
 * адденду, извлечении нужной части результата и помещении её
 * в перемещаемое поле.
 *
 * Если несколько последовательных записей о перемещении применяются
 * к одному и тому же местоположению (r_offset), они композируются,
 * а не применяются независимо.
 *
 *
 * ---------------------------------------------------------------------
 * 6.2. Таблица относительных перемещений
 * ---------------------------------------------------------------------
 * Записи таблицы относительных перемещений:
 */
typedef Elf32_Word Elf32_Relr;
typedef Elf64_Xword Elf64_Relr;

/*
 * Относительные перемещения используются для идентификации
 * единиц хранения размером с виртуальный адрес внутри объекта,
 * содержимое которых не зависит от какой-либо динамической
 * привязки, но всё же должно быть перемещено во время загрузки
 * для поддержки позиционной независимости. Перед тем как
 * программа сможет начать выполнение, эти местоположения должны
 * быть перемещены путём чтения их содержимого и добавления
 * фактора перемещения, который вычисляется как разница между
 * фактическим виртуальным адресом объекта во время загрузки
 * и его виртуальным адресом во время компоновки.
 *
 * Таблица относительных перемещений кодируется как
 * последовательность записей Elf32_Relr или Elf64_Relr.
 * Эти записи декодируются в список виртуальных адресов,
 * которые ссылаются на единицы хранения внутри объекта.
 *
 * * Примечание:
 *   Относительные перемещения можно было бы представить просто
 *   как список виртуальных адресов, требующих перемещения,
 *   что было бы значительно компактнее, чем использование
 *   перемещений типа Rel или Rela. Однако, поскольку многие
 *   такие перемещения происходят группами, мы можем использовать
 *   простую схему кодирования для ещё большего сжатия таблицы
 *   относительных перемещений.
 *
 * Закодированная последовательность записей Elf32_Relr или
 * Elf64_Relr начинается с адресной записи (которая должна иметь
 * 0 в младшем бите). Это кодирует одно относительное
 * перемещение по этому адресу. За этой адресной записью могут
 * следовать ноль или более записей с битовой картой, каждая из
 * которых имеет 1 в младшем бите.
 *
 * Записи с битовой картой описывают блок последовательных единиц
 * хранения, следующих сразу за той, к которой применялась
 * адресная запись. Каждая запись с битовой картой охватывает
 * 31 (для Elf32_Relr) или 63 (для Elf64_Relr) единицы хранения.
 * Каждый бит в записи с битовой картой, за исключением младшего,
 * соответствует единице хранения в блоке. Если бит установлен
 * в 1, соответствующая единица хранения подлежит перемещению.
 */
