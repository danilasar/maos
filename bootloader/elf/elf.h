/*
 * =====================================================================
 * 1. Введение
 * =====================================================================
 *
 * Существует три основных типа объектных файлов.
 *
 * 1. Перемещаемый файл
 * Содержит код и данные, подходящие для связывания (компоновки)
 * с другими объектными файлами с целью создания исполняемого
 * или разделяемого объектного файла.
 *
 * 2. Исполняемый файл
 * Содержит программу, готовую к выполнению. Этот файл указывает,
 * как система (например, через системный вызов exec()) создает
 * образ процесса программы в памяти.
 *
 * 3. Разделяемый объектный файл
 * Содержит код и данные, которые могут быть связаны в двух контекстах.
 * Во-первых, редактор связей (компоновщик) обрабатывает разделяемый
 * объектный файл вместе с другими перемещаемыми и разделяемыми
 * объектными файлами для создания нового объектного файла.
 * Во-вторых, динамический компоновщик объединяет его с исполняемым
 * файлом и другими разделяемыми объектами для создания образа процесса.
 *
 * Объектные файлы создаются ассемблером и компоновщиком и
 * представляют собой двоичное представление программ,
 * предназначенных для непосредственного выполнения на процессоре.
 *
 * Программы, требующие другие абстрактных машины, такие как shell-скрипты,
 * сюда не относятся.
 *
 * ---------------------------------------------------------------------
 * 1.1. Формат файла
 * ---------------------------------------------------------------------
 * Объектные файлы участвуют как в компоновке программы (сборке),
 * так и в её выполнении (запуске).
 *
 * Для удобства и эффективности формат объектного файла предоставляет
 * параллельные представления содержимого файла, отражающие
 * различные потребности этих двух процессов.
 *
 *  Представление для компоновки              Представление для выполнения
 *  +------------------------+                +------------------------+
 *  |       Заголовок        |                |       Заголовок        |
 *  +------------------------+                +------------------------+
 *  |  Заголовочная таблица  | опционально    |  Заголовочная таблица  | обязательно
 *  |        программы       |                |        программы       |
 *  +------------------------+                +------------------------+
 *  |        Секция 1        |                |        Сегмент 1       |
 *  +------------------------+                +------------------------+
 *  |        Секция 2        |                |        Сегмент 2       |
 *  +------------------------+                +------------------------+
 *  |        Секция 3        |                |        Сегмент 3       |
 *  +------------------------+                +------------------------+
 *  |          ...           |                |          ...           |
 *  +------------------------+                +------------------------+
 *  |  Заголовочная таблица  | обязательно    |  Заголовочная таблица  | опционально
 *  |         секций         |                |         секций         |
 *  +------------------------+                +------------------------+
 *
 * Заголовок ELF располагается в самом начале файла и содержит дорожную карту,
 * описывающую организацию файла.
 *
 * Секции содержат основную часть информации объектного файла
 * для представления компоновки: инструкции, данные,
 * таблицу символов, информацию о перемещениях и так далее.
 *
 * Заголовочная таблица программы сообщает системе,
 * как создать образ процесса. Файлы, используемые для сборки образа
 * процесса (для выполнения программы), должны иметь таблицу заголовков программы;
 * перемещаемым файлам она не нужна.
 *
 * Таблица заголовков секций содержит информацию,
 * описывающую секции файла. Каждая секция имеет свою запись в этой таблице;
 * каждая запись предоставляет информацию, такую как имя секции,
 * её размер и так далее. Файлы, используемые во время компоновки,
 * должны иметь таблицу заголовков секций; другие объектные файлы
 * могут иметь её, а могут и не иметь.
 *
 * * Примечание:
 * Хотя рисунок выше показывает, что таблица заголовков
 * программы следует сразу за заголовком ELF, а таблица заголовков
 * секций - после всех секций, реальные файлы могут отличаться.
 * Более того, секции и сегменты не имеют определённого порядка.
 * Только заголовок ELF имеет фиксированное положение в файле.
 *
 * ---------------------------------------------------------------------
 * 1.2. Типы данных
 * ---------------------------------------------------------------------
 * Формат объектного файла поддерживает различные процессоры с 8-битными
 * байтами и либо 32-битными, либо 64-битными архитектурами.
 * Тем не менее, он подходит и для расширения на более крупные
 * (или меньшие) архитектуры.
 *
 * Поэтому объектные файлы представляют некоторые управляющие данные
 * в машинно-независимом формате, что позволяет идентифицировать
 * объектные файлы и интерпретировать их содержимое общим образом.
 * Остальные данные в объектном файле используют кодировку целевого
 * процессора, независимо от того, на какой машине был создан файл.
 *
 * Все структуры данных, определяемые форматом объектного файла, следуют
 * естественным правилам размера и выравнивания для соответствующего
 * класса. При необходимости, структуры данных содержат явное заполнение
 * (padding), чтобы обеспечить выравнивание 8-байтовых объектов по
 * 8-байтовой границе, 4-байтовых объектов по 4-байтовой границе,
 * чтобы принудительно сделать размеры структур кратными 4 или 8,
 * и так далее. Данные также имеют подходящее выравнивание от начала файла.
 * Таким образом, например, структура, содержащая поле Elf32_Addr, будет
 * выровнена по 4-байтовой границе внутри файла.
 *
 * По соображениям переносимости ELF не использует битовые поля.
 *
 * 32-разрядные типы данных:
 */
typedef unsigned long  Elf32_Addr;   // Программный адрес
typedef unsigned long  Elf32_Off;    // Смещение
typedef unsigned short Elf32_Half;   // Среднее беззнаковое число
typedef signed long    Elf32_Sword;  // Длинное знаковое число
typedef unsigned long  Elf32_Word;   // Длинное беззнаковое число
/*
 * 64-разрядные типы данных:
 */
typedef unsigned long long Elf64_Addr;   // Программный адрес
typedef unsigned long long Elf64_Off;    // Смещение
typedef unsigned short     Elf64_Half;   // Среднее беззнаковое число
typedef unsigned long      Elf64_Word;   // Беззнаковое число
typedef   signed long      Elf64_Sword;  // Знаковое число
typedef unsigned long long Elf64_Xword;  // Длинное беззнаковое число
typedef unsigned long long Elf64_Sxword; // Длинное знаковое число

/* ---------------------------------------------------------------------
 * 1.3. Расширяемость
 * ---------------------------------------------------------------------
 * Заголовок ELF содержит номер версии, который может быть увеличен
 * при крупных изменениях формата объектного файла. Однако ELF был
 * спроектирован так, что такие крупные изменения редки, и формат файла
 * может быть расширен несколькими способами, не требующими изменения
 * номера версии.
 *
 * Большинство структур объектного файла содержатся в секциях
 * (см. главу про секции) и обозначаются специальными
 * типами секций. Дополнительные управляющие структуры могут быть
 * определены путем создания новых типов секций.
 *
 * Многие управляющие структуры имеют поля с перечисляемыми значениями,
 * и стандарт резервирует определенные диапазоны значений для этих полей
 * для специфичных для реализации использований. Эти расширения могут
 * относиться к одному из двух классов: специфичные для процессора
 * расширения, которые зависят от архитектуры машины (см. e_machine
 * в содержимом заголовка ELF); и специфичные для OSABI расширения,
 * которые зависят от операционной системы и psABI
 * (см. EI_OSABI в главе про заголовок ELF).
 *
 * ELF присваивает значения полям и константам во всей спецификации.
 * Любые неназначенные биты или значения, неявно делегированные psABI
 * или OSABI, зарезервированы стандартом ELF для возможного будущего
 * использования. Реализации не должны присваивать значения или иным
 * образом использовать любые неназначенные элементы.
 *
 * Некоторые управляющие структуры объектного файла могут расти, поскольку
 * заголовок ELF содержит их фактические размеры. Если формат объектного
 * файла изменится, программа может столкнуться с управляющими структурами,
 * которые больше или меньше ожидаемых. Поэтому программы могут игнорировать
 * лишнюю информацию. Обработка "отсутствующей" информации зависит
 * от контекста и будет определена, когда и если будут определены
 * расширения. Эта форма расширения зарезервирована для будущих ревизий
 * стандарта ELF и не должна использоваться для специфичных для реализации
 * целей.
 *
 * ---------------------------------------------------------------------
 * 1.4. Обязательные возможности
 * ---------------------------------------------------------------------
 * Стандарт ELF описывает широкий набор структур (специальные секции,
 * типы символов и т.д.), но не требует, чтобы каждая система
 * поддерживала их все. Какие именно функции являются обязательными
 * для конкретной операционной системы или процессора, определяется
 * в отдельном документе — спецификации ABI для этой платформы (psABI).
 *
 * =====================================================================
 * 2. Заголовок объектного файла
 * =====================================================================
 * Заголовок объектного файла располагается в самом начале ELF-файла.
 * Он идентифицирует файл как объектный и содержит
 * информацию, необходимую для интерпретации содержимого и для
 * нахождения других его компонентов.
 */

#include "elf/header.h"

/*
 * =====================================================================
 * 3. Секции
 * =====================================================================
 * Секции содержат всю информацию в объектном файле, за исключением
 * заголовка объектного файла, таблицы заголовков программы и таблицы
 * заголовков секций.
 * 
 * Найти каждую из них можно по таблице заголовков секций, положение
 * и размер которой указывается в заголовке файла.
 */

#include "elf/sections.h"

/*
 * =====================================================================
 * 4. Таблица строк
 * =====================================================================
 *
 * Секции таблиц строк содержат последовательности символов,
 * завершающиеся нулевым символом, обычно называемые строками.
 * Объектный файл использует эти строки для представления имен
 * символов и секций. Ссылка на строку осуществляется через
 * индекс в секции таблицы строк.
 *
 * Первый байт, имеющий индекс ноль, по определению должен
 * содержать нулевой символ. Аналогично, последний байт
 * таблицы строк также должен содержать нулевой символ,
 * обеспечивая тем самым нулевое завершение для всех строк.
 * Строка с индексом ноль означает либо отсутствие имени,
 * либо нулевое имя, в зависимости от контекста.
 *
 * Допускается наличие пустой секции таблицы строк; в этом
 * случае поле sh_size её заголовка будет содержать ноль.
 * Ненулевые индексы для пустой таблицы строк недопустимы.
 *
 * Поле sh_name заголовка секции содержит индекс в секции
 * таблицы строк имён секций, на которую указывает поле
 * e_shstrndx заголовка объектного файла. Следующие рисунки
 * показывают таблицу строк размером 25 байт и строки,
 * связанные с различными индексами.
 *
 *
 * Таблица строк
 * +----+----+----+----+----+----+----+----+----+----+----+
 * | \0 | n  | a  | m  | e  | .  | \0 | V  | a  | r  | i  |
 * +----+----+----+----+----+----+----+----+----+----+----+
 *   0    1    2    3    4    5    6    7    8    9    10
 *
 * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+
 * | a  | b  | l  | e  | \0 | S  | u  | p  | p  | l  | y  | \0 | \0 | \0 |
 * +----+----+----+----+----+----+----+----+----+----+----+----+----+----+
 *  11   12   13   14   15   16   17   18   19   20   21   22   23   24
 *
 *
 * Связь индексов и строк
 * +--------+----------+---------------+
 * | Индекс |  Строка  |     Размер    |
 * +--------+----------+---------------+
 * |    0   | (null)   |       1       |
 * |    1   | name.    |       6       |
 * |    7   | Variable |       9       |
 * |   11   | able     |       5       |
 * |   16   | Supply   |       7       |
 * |   23   | (null)   |       1       |
 * |   24   | (null)   |       1       |
 * +-=------+----------+---------------+
 *
 * Как показано в примере, индекс таблицы строк может ссылаться
 * на любой байт в секции. Одна и та же строка может встречаться
 * несколько раз; могут существовать ссылки на подстроки;
 * и на одну строку можно ссылаться многократно. Также
 * допускается наличие строк, на которые нет ссылок.
 *
 *
 * =====================================================================
 * 5. Таблица символов
 * =====================================================================
 *
 * Таблица символов объектного файла содержит информацию,
 * необходимую для нахождения и перемещения
 * символических определений и ссылок программы. Индекс
 * таблицы символов является индексом в этом массиве.
 *
 * Индекс 0 одновременно обозначает первую запись в таблице
 * и служит в качестве индекса неопределённого символа.
 */

#include "elf/symbols.h"
